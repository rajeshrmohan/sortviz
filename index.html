<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SortViz: An Interactive Algorithm Comparison Tool</title>
    <style>
        :root {
            --bar-default: #3498db;
            --bar-compare: #f1c40f;   /* Yellow */
            --bar-write: #e74c3c;     /* Red */
            --bar-sorted: #2ecc71;    /* Green */
            --bar-pivot: #9b59b6;     /* Purple */

            --bg-color: #2c3e50;
            --text-color: #ecf0f1;
            --control-bg: #34495e;
            --highlight-bg: #4a627a;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { text-align: center; }

        .controls {
            background-color: var(--control-bg);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 1100px;
            box-sizing: border-box;
        }

        .controls button, .controls select {
            background-color: var(--bar-default);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .controls button:hover, .controls select:hover { background-color: #2980b9; }
        .controls button:disabled { background-color: #7f8c8d; cursor: not-allowed; }
        .slider-container { display: flex; flex-direction: column; align-items: center; gap: 5px; }

        .visualization-area {
            width: 100%;
            max-width: 1100px;
            height: 400px;
            background-color: #ecf0f1;
            border: 2px solid var(--control-bg);
            border-radius: 8px;
            display: flex;
            align-items: flex-end;
            padding: 10px;
            box-sizing: border-box;
            gap: 2px;
        }

        .bar {
            flex-grow: 1;
            background-color: var(--bar-default);
            transition: height 0.2s ease, background-color 0.2s ease;
            color: var(--bg-color);
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding-top: 5px;
            box-sizing: border-box;
            overflow: hidden;
        }

        .aux-container {
            display: none; /* Hidden by default */
            flex-wrap: wrap;
            gap: 5px;
            width: 100%;
            max-width: 1100px;
            min-height: 60px;
            margin-top: 10px;
            padding: 10px;
            background-color: var(--control-bg);
            border-radius: 8px;
            align-items: center;
        }

        .aux-box {
            background-color: #ecf0f1;
            color: #2c3e50;
            padding: 5px;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
            min-width: 30px;
            transition: background-color 0.3s;
        }
        .aux-box .label { font-weight: bold; display: block; }
        .aux-box .value { font-size: 1.2em; }
        
        .bottom-section {
            display: flex;
            flex-wrap: nowrap;
            gap: 20px;
            width: 100%;
            max-width: 1100px;
            margin-top: 20px;
        }

        .explanation-box, .code-display {
            flex: 1;
            background-color: var(--control-bg);
            padding: 20px;
            border-radius: 8px;
            min-height: 250px;
        }
        
        h3 { margin-top: 0; border-bottom: 2px solid var(--text-color); padding-bottom: 10px; }
        #explanation-text { font-size: 1.1em; line-height: 1.5; }
        pre { background-color: #2c3e50; padding: 15px; border-radius: 5px; white-space: pre-wrap; font-size: 14px; }
        code span { display: block; border-radius: 3px; transition: background-color 0.2s; }
        .highlight { background-color: var(--highlight-bg) !important; }
    </style>
</head>
<body>

    <h1>SortViz: An Interactive Algorithm Comparison Tool</h1>

    <div class="controls">
        <select id="algorithm-select">
            <optgroup label="Simple Sorts">
                <option value="bubble">Bubble Sort</option>
                <option value="selection">Selection Sort</option>
                <option value="insertion">Insertion Sort</option>
            </optgroup>
            <optgroup label="Efficient Sorts">
                <option value="merge">Merge Sort</option>
                <option value="quick">Quick Sort</option>
                <option value="heap">Heap Sort</option>
            </optgroup>
            <optgroup label="Special Sorts">
                <option value="counting">Counting Sort</option>
            </optgroup>
        </select>
        <button id="randomize-btn">Randomize Array</button>
        <div class="slider-container">
            <label for="size-slider">Array Size: <span id="size-value">50</span></label>
            <input type="range" id="size-slider" min="5" max="100" value="50">
        </div>
        <div class="slider-container">
            <label for="speed-slider">Speed: <span id="speed-value">Medium</span></label>
            <input type="range" id="speed-slider" min="10" max="200" value="100">
        </div>
        <button id="start-btn">Start Sort</button>
    </div>

    <div class="visualization-area" id="bar-container"></div>
    <div class="aux-container" id="aux-container"></div>

    <div class="bottom-section">
        <div class="explanation-box">
            <h3>Explanation</h3>
            <p id="explanation-text">Select an algorithm and click 'Start Sort' to begin.</p>
        </div>
        <div class="code-display">
            <h3>Code</h3>
            <pre><code id="code-block"></code></pre>
        </div>
    </div>

    <script>
        // DOM Elements
        const barContainer = document.getElementById('bar-container');
        const auxContainer = document.getElementById('aux-container');
        const randomizeBtn = document.getElementById('randomize-btn');
        const startBtn = document.getElementById('start-btn');
        const algorithmSelect = document.getElementById('algorithm-select');
        const sizeSlider = document.getElementById('size-slider');
        const speedSlider = document.getElementById('speed-slider');
        const sizeValue = document.getElementById('size-value');
        const speedValue = document.getElementById('speed-value');
        const explanationText = document.getElementById('explanation-text');
        const codeBlock = document.getElementById('code-block');

        // State
        let array = [];
        let isSorting = false;
        let animationSpeed = 100;

        // --- CODE SNIPPETS ---
        const CODE_SNIPPETS = {
            bubble: `async function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // Swap arr[j] and arr[j+1]
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
      }
    }
  }
}`,
            selection: `async function selectionSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let minIdx = i;
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIdx]) {
        minIdx = j;
      }
    }
    // Swap the found minimum element
    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
  }
}`,
            insertion: `async function insertionSort(arr) {
  let n = arr.length;
  for (let i = 1; i < n; i++) {
    let key = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j = j - 1;
    }
    arr[j + 1] = key;
  }
}`,
            merge: `async function mergeSort(arr, l, r) {
  if (l >= r) return;
  let m = l + Math.floor((r - l) / 2);
  await mergeSort(arr, l, m);
  await mergeSort(arr, m + 1, r);
  await merge(arr, l, m, r);
}
// Merging function will be visualized
// separately.`,
            quick: `async function quickSort(arr, low, high) {
  if (low < high) {
    let pi = await partition(arr, low, high);
    await quickSort(arr, low, pi - 1);
    await quickSort(arr, pi + 1, high);
  }
}
// Partitioning logic is the core of
// the visualization.`,
            heap: `async function heapSort(arr) {
  let n = arr.length;
  // Build max heap
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    await heapify(arr, n, i);
  }
  // Extract elements from heap one by one
  for (let i = n - 1; i > 0; i--) {
    // Move current root to end
    [arr[0], arr[i]] = [arr[i], arr[0]];
    // Call max heapify on the reduced heap
    await heapify(arr, i, 0);
  }
}`,
            counting: `async function countingSort(arr) {
  let max = Math.max(...arr);
  let min = Math.min(...arr);
  let range = max - min + 1;
  let count = new Array(range).fill(0);
  let output = new Array(arr.length);

  // Store count of each character
  for (let i = 0; i < arr.length; i++) {
    count[arr[i] - min]++;
  }

  // Place the objects in sorted order
  // This part is simplified for visualization
}`
        };

        // --- UTILITY & VISUALIZATION FUNCTIONS ---
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function highlightCodeLine(line) {
            Array.from(codeBlock.children).forEach(span => span.classList.remove('highlight'));
            if (line) {
                const targetLine = codeBlock.querySelector(`span:nth-child(${line})`);
                if (targetLine) targetLine.classList.add('highlight');
            }
        }

        function updateExplanation(text) {
            explanationText.textContent = text;
        }

        function setControlsState(disabled) {
            isSorting = disabled;
            [randomizeBtn, startBtn, algorithmSelect, sizeSlider].forEach(el => el.disabled = disabled);
        }

        function generateRandomArray() {
            array = [];
            const size = sizeSlider.value;
            const maxValue = algorithmSelect.value === 'counting' ? 50 : 100; // Smaller range for counting sort
            const minValue = algorithmSelect.value === 'counting' ? 10 : 5;
            sizeValue.textContent = size;
            for (let i = 0; i < size; i++) {
                array.push(Math.floor(Math.random() * (maxValue - minValue + 1)) + minValue);
            }
            renderBars();
            updateExplanation("New random array generated. Select an algorithm to begin.");
        }

        function renderBars(specialIndices = {}) {
            barContainer.innerHTML = '';
            array.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.classList.add('bar');
                bar.style.height = `${value * 3.5}px`;
                bar.textContent = value;
                if (specialIndices[index]) {
                    bar.style.backgroundColor = `var(--bar-${specialIndices[index]})`;
                }
                barContainer.appendChild(bar);
            });
        }
        
        async function updateBar(index, value, color) {
            const bars = document.getElementsByClassName('bar');
            if(bars[index]){
                bars[index].style.height = `${value * 3.5}px`;
                bars[index].textContent = value;
                bars[index].style.backgroundColor = `var(--bar-${color})`;
            }
            await sleep(animationSpeed);
        }

        async function colorBar(index, color) {
            const bars = document.getElementsByClassName('bar');
            if (bars[index]) {
                bars[index].style.backgroundColor = `var(--bar-${color})`;
            }
            await sleep(animationSpeed);
        }

        async function swap(i, j) {
            [array[i], array[j]] = [array[j], array[i]];
            const bars = document.getElementsByClassName('bar');
            const tempHeight = bars[i].style.height;
            const tempText = bars[i].textContent;

            bars[i].style.height = bars[j].style.height;
            bars[i].textContent = bars[j].textContent;
            bars[j].style.height = tempHeight;
            bars[j].textContent = tempText;

            await sleep(animationSpeed);
        }


        // --- SORTING ALGORITHMS ---

        // Bubble Sort
        async function bubbleSort() {
            const n = array.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    await colorBar(j, 'compare');
                    await colorBar(j + 1, 'compare');
                    updateExplanation(`Comparing ${array[j]} and ${array[j+1]}.`);
                    highlightCodeLine(5);
                    await sleep(animationSpeed);

                    if (array[j] > array[j + 1]) {
                        updateExplanation(`Swapping ${array[j]} and ${array[j+1]}.`);
                        highlightCodeLine(7);
                        await colorBar(j, 'write');
                        await colorBar(j+1, 'write');
                        await swap(j, j + 1);
                    }
                    await colorBar(j, 'default');
                    await colorBar(j + 1, 'default');
                }
                await colorBar(n - 1 - i, 'sorted');
            }
            await colorBar(0, 'sorted');
        }

        // Selection Sort
        async function selectionSort() {
            const n = array.length;
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                await colorBar(i, 'pivot'); // Using pivot color for current position
                updateExplanation(`Finding minimum for position ${i}.`);
                highlightCodeLine(4);
                
                for (let j = i + 1; j < n; j++) {
                    await colorBar(j, 'compare');
                    highlightCodeLine(6);
                    if (array[j] < array[minIdx]) {
                        if (minIdx !== i) await colorBar(minIdx, 'default');
                        minIdx = j;
                        await colorBar(minIdx, 'write'); // New minimum found
                        updateExplanation(`New minimum found: ${array[minIdx]}.`);
                    } else {
                        await colorBar(j, 'default');
                    }
                }

                if (minIdx !== i) {
                    updateExplanation(`Swapping ${array[i]} with minimum ${array[minIdx]}.`);
                    highlightCodeLine(10);
                    await swap(i, minIdx);
                }
                
                await colorBar(minIdx, 'default');
                await colorBar(i, 'sorted');
            }
             await colorBar(n-1, 'sorted');
        }
        
        // Insertion Sort
        async function insertionSort() {
            const n = array.length;
            await colorBar(0, 'sorted');
            for (let i = 1; i < n; i++) {
                let key = array[i];
                let j = i - 1;
                await colorBar(i, 'pivot');
                updateExplanation(`Picking ${key} to insert into the sorted part.`);
                highlightCodeLine(4);
                await sleep(animationSpeed);

                highlightCodeLine(6);
                while (j >= 0 && array[j] > key) {
                    await colorBar(j, 'compare');
                    updateExplanation(`${array[j]} > ${key}, shifting ${array[j]} to the right.`);
                    highlightCodeLine(7);
                    array[j + 1] = array[j];
                    await updateBar(j + 1, array[j+1], 'write');
                    await colorBar(j, 'sorted');
                    j = j - 1;
                }
                array[j + 1] = key;
                updateExplanation(`Inserting ${key} at its correct position.`);
                highlightCodeLine(10);
                await updateBar(j + 1, key, 'sorted');

                for(let k=0; k<=i; k++) await colorBar(k, 'sorted');
            }
        }
        
        // Merge Sort
        async function mergeSort(l, r) {
            if (l >= r) return;
            highlightCodeLine(2);
            let m = l + Math.floor((r - l) / 2);
            
            updateExplanation(`Splitting array from index ${l} to ${r}.`);
            await sleep(animationSpeed);
            
            highlightCodeLine(4);
            await mergeSort(l, m);
            highlightCodeLine(5);
            await mergeSort(m + 1, r);
            
            updateExplanation(`Merging subarrays from ${l} to ${m} and ${m+1} to ${r}.`);
            highlightCodeLine(6);
            await merge(l, m, r);
        }

        async function merge(l, m, r) {
            let n1 = m - l + 1;
            let n2 = r - m;
            let L = new Array(n1);
            let R = new Array(n2);

            for (let i = 0; i < n1; i++) L[i] = array[l + i];
            for (let j = 0; j < n2; j++) R[j] = array[m + 1 + j];

            let i = 0, j = 0, k = l;
            while (i < n1 && j < n2) {
                await colorBar(l + i, 'compare');
                await colorBar(m + 1 + j, 'compare');
                if (L[i] <= R[j]) {
                    array[k] = L[i];
                    await updateBar(k, array[k], 'write');
                    i++;
                } else {
                    array[k] = R[j];
                    await updateBar(k, array[k], 'write');
                    j++;
                }
                await colorBar(k, 'default');
                k++;
            }
            while (i < n1) {
                array[k] = L[i];
                await updateBar(k, array[k], 'write');
                await colorBar(k, 'default');
                i++; k++;
            }
            while (j < n2) {
                array[k] = R[j];
                await updateBar(k, array[k], 'write');
                await colorBar(k, 'default');
                j++; k++;
            }
            for(let idx = l; idx <=r; idx++) await colorBar(idx, 'sorted');
        }

        // Quick Sort
        async function quickSort(low, high) {
            if (low < high) {
                highlightCodeLine(2);
                updateExplanation(`Partitioning from index ${low} to ${high}.`);
                let pi = await partition(low, high);
                highlightCodeLine(4);
                await quickSort(low, pi - 1);
                highlightCodeLine(5);
                await quickSort(pi + 1, high);
            }
            if(low >= 0 && low < array.length) await colorBar(low, 'sorted');
            if(high >= 0 && high < array.length) await colorBar(high, 'sorted');
        }

        async function partition(low, high) {
            let pivot = array[high];
            await colorBar(high, 'pivot');
            updateExplanation(`Pivot is ${pivot} at index ${high}.`);
            let i = low - 1;

            for (let j = low; j < high; j++) {
                await colorBar(j, 'compare');
                if (array[j] < pivot) {
                    i++;
                    await colorBar(i, 'write');
                    await colorBar(j, 'write');
                    await swap(i, j);
                    await colorBar(i, 'default');
                }
                await colorBar(j, 'default');
            }
            await colorBar(i+1, 'write');
            await colorBar(high, 'write');
            await swap(i + 1, high);
            await colorBar(i + 1, 'sorted');
            await colorBar(high, 'default');
            return i + 1;
        }

        // Heap Sort
        async function heapSort() {
            let n = array.length;
            updateExplanation('Building max heap...');
            highlightCodeLine(4);
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                await heapify(n, i);
            }
            updateExplanation('Extracting elements from heap...');
            highlightCodeLine(8);
            for (let i = n - 1; i > 0; i--) {
                await colorBar(0, 'write');
                await colorBar(i, 'write');
                await swap(0, i);
                await colorBar(i, 'sorted');
                await heapify(i, 0);
            }
            await colorBar(0, 'sorted');
        }

        async function heapify(n, i) {
            let largest = i;
            let l = 2 * i + 1;
            let r = 2 * i + 2;

            await colorBar(largest, 'pivot');
            if (l < n) await colorBar(l, 'compare');
            if (r < n) await colorBar(r, 'compare');

            if (l < n && array[l] > array[largest]) largest = l;
            if (r < n && array[r] > array[largest]) largest = r;

            if (largest !== i) {
                await colorBar(i, 'write');
                await colorBar(largest, 'write');
                await swap(i, largest);
                await colorBar(largest, 'default');
                await heapify(n, largest);
            }

            await colorBar(i, 'default');
            if (l < n) await colorBar(l, 'default');
            if (r < n) await colorBar(r, 'default');
        }
        
        // Counting Sort
        async function countingSort() {
            let min = Math.min(...array);
            let max = Math.max(...array);
            let range = max - min + 1;
            let count = new Array(range).fill(0);

            // Setup auxiliary display
            auxContainer.innerHTML = '';
            for (let i=0; i < range; i++) {
                const box = document.createElement('div');
                box.className = 'aux-box';
                box.innerHTML = `<span class="label">${min + i}</span><span class="value">0</span>`;
                auxContainer.appendChild(box);
            }
            const auxBoxes = auxContainer.children;

            updateExplanation('Counting occurrences of each element...');
            highlightCodeLine(9);
            for (let i = 0; i < array.length; i++) {
                let val = array[i];
                await colorBar(i, 'compare');
                count[val - min]++;
                const box = auxBoxes[val-min];
                box.children[1].textContent = count[val - min];
                box.style.backgroundColor = 'var(--bar-write)';
                await sleep(animationSpeed);
                box.style.backgroundColor = '#ecf0f1';
                await colorBar(i, 'default');
            }

            updateExplanation('Placing elements back into the main array...');
            highlightCodeLine(13);
            let j = 0;
            for (let i = 0; i < range; i++) {
                const box = auxBoxes[i];
                box.style.backgroundColor = 'var(--bar-compare)';
                while (count[i] > 0) {
                    array[j] = i + min;
                    await updateBar(j, array[j], 'write');
                    await colorBar(j, 'sorted');
                    count[i]--;
                    box.children[1].textContent = count[i];
                    j++;
                }
                box.style.backgroundColor = '#ecf0f1';
            }
        }


        // --- EVENT HANDLERS & INITIALIZATION ---

        function updateAlgorithmSelection() {
            const selectedAlgo = algorithmSelect.value;
            const formattedCode = CODE_SNIPPETS[selectedAlgo].split('\n').map(line => `<span>${line}</span>`).join('');
            codeBlock.innerHTML = formattedCode;
            
            // Show/Hide aux container for counting sort
            auxContainer.style.display = selectedAlgo === 'counting' ? 'flex' : 'none';
            generateRandomArray();
        }

        async function startSort() {
            setControlsState(true);
            const selectedAlgo = algorithmSelect.value;
            switch (selectedAlgo) {
                case 'bubble': await bubbleSort(); break;
                case 'selection': await selectionSort(); break;
                case 'insertion': await insertionSort(); break;
                case 'merge': 
                    await mergeSort(0, array.length - 1); 
                    for(let i=0; i<array.length; i++) await colorBar(i, 'sorted');
                    break;
                case 'quick': 
                    await quickSort(0, array.length - 1); 
                    break;
                case 'heap': await heapSort(); break;
                case 'counting': await countingSort(); break;
            }
            updateExplanation('Sorting complete!');
            setControlsState(false);
        }

        // Event Listeners
        randomizeBtn.addEventListener('click', generateRandomArray);
        startBtn.addEventListener('click', startSort);
        algorithmSelect.addEventListener('change', updateAlgorithmSelection);
        
        sizeSlider.addEventListener('input', () => {
            sizeValue.textContent = sizeSlider.value;
            if (!isSorting) generateRandomArray();
        });

        speedSlider.addEventListener('input', () => {
            animationSpeed = 210 - speedSlider.value;
            const speedLabels = { 10: 'Slowest', 50: 'Slow', 100: 'Medium', 150: 'Fast', 200: 'Fastest' };
            const closest = Object.keys(speedLabels).reduce((a, b) => Math.abs(b - speedSlider.value) < Math.abs(a - speedSlider.value) ? b : a);
            speedValue.textContent = speedLabels[closest];
        });

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            updateAlgorithmSelection();
            speedSlider.dispatchEvent(new Event('input'));
        });

    </script>
</body>
</html>